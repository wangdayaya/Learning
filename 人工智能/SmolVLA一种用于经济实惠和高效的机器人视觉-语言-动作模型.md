 

https://arxiv.org/pdf/2506.01844

# 摘要

1.  与从头开始训练策略相比，近期的方法将 VLMs 适配为视觉语言动作 VLA 模型，从而能够实现由自然语言驱动的感知和控制。
1.  现有的 VLA 模型具有高昂的训练成本和有限的实际部署可行性。此外，它们依赖于学术和工业数据集。
1.  SmolVLA是一个小巧、高效且由社区驱动的 VLA ，它极大地降低了训练和推理成本，尽管其规模紧凑，但 SmolVLA的性能却可与规模大 10 倍的 VLAs 相媲美。
1.  SmolVLA 的设计宗旨是在单个 GPU 上进行训练，并在消费级 GPU 甚至 CPU 上部署。
1.  为了进一步提升响应速度，我们引入了一种异步推理堆栈，将感知和动作预测与动作执行解耦，从而能够以分块动作生成的方式实现更高的控制速率。
1.  SmolVLA 由一个紧凑的预训练 VLM 组成，丢弃了最后 $$(L-N)$$层（剪刀图标）。剩余的层嵌入了三个输入：（i）语言指令，（ii）RGB图像，以及（iii）机器人传感器状态。它们的合并 token 送到一个动作专家，该专家由交替的交叉注意力（金色）和自注意力（浅黄色）块组成，通过流匹配（ flow matching）训练以输出 $$n$$ 个低级动作块 $$(a_t, \ldots, a_{t+n})$$。SmolVLA 在公共社区数据集上进行预训练，并在平价机器人上进行评估。

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/3aa9d1ee9a904dcab771bc545a5a0b45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv546L5aSn5L2g5piv6LCB:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTM2MjE3NDA1ODk1MTQ5In0%3D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1750240989&x-orig-sign=oqituIr8yR7aya1YSmX%2BH89yPU0%3D)

# 介绍

1.  SmolVLA 是一个开源的、紧凑但功能强大的视觉-语言代理（VLA）模型。该模型旨在优化在消费级GPU上的训练以及在CPU上的部署。

1.  轻量级架构，SmolVLA 通过以下设计选择实现轻量化：

    - 跳过视觉-语言模型（VLM）中的一些层。
    - 使用最少数量的视觉标记。
    - 利用小型预训练的视觉-语言模型（VLMs）。
    - 在 self-attention 层中交错使用较轻的 cross-attention 。

1.  社区驱动的数据集预训练， SmolVLA 在少于 30k 的公开可用、社区贡献的数据集上进行端到端训练。即使使用的数据量比之前的 SOTA 少一个数量级，也表现出强大的性能。

1.  异步推理，引入了优化的异步推理堆栈，将动作执行与观察处理和动作预测解耦，减少延迟并实现快速、资源高效的推理。

  


# **模型架构**

**概述**：SmolVLA 是一个轻量级 VLA ，由一个紧凑的预训练 VLM 和一个通过流匹配训练的 action expert 动作专家组成。给定多张图像和描述任务的语言指令，模型输出一系列动作。

SmolVLA 由两个主要组件组成：（i）一个负责感知的预训练视觉语言模型（VLM），以及（ii）一个负责执行动作的动作专家。这两个组件是相互连接的，因为 VLM 处理状态输入以生成特征，这些特征驱动动作专家，进而产生动作，这些动作反过来改变 VLM 的状态。具体来说，VLM 处理传感器状态，包括来自多个 RGB 摄像头的图像，以及描述任务的语言指令。反过来，VLM 直接将特征输出到动作专家，动作专家输出最终的连续动作。

**视觉-语言模型（VLM）** ：我们利用预训练的 VLM 作为感知机器人环境的主要 backbone 。VLM 在多样的多模态数据上预训练，捕捉丰富的世界知识。为了保证效率和可访问性，我们选择 SmolVLM-2 ，这是一个针对多图像和视频输入优化的高效模型。SmolVLM-2 依赖 SigLIP 来为 SmolLM2 语言解码器编码视觉特征。在 SmolVLA 中，VLM组件使用视觉编码器处理图像序列，这通过一种 token-shuffling 技术减少了 token 数量来提高效率。语言指令被标记化为文本 token 。传感器状态通过一个线性层投影为单个 token ，以匹配语言模型的 token 维度。最后，视觉、语言和状态三种 token 被拼接起来传递给语言解码器。然后使用解码器层的结果来条件化动作专家。

**状态、动作和特征投影器**：我们在 SmolVLA 内部的多个关键点使用线性投影层。特别是，我们使用线性投影层来（i）将状态投影以匹配 VLM 维度（ii）将动作投影以匹配动作专家的维度，（iii）调整 VLM 特征以对齐动作专家的维度。

**视觉令牌减少**：虽然高分辨率图像对 VLM 性能至关重要，但会增加推理成本。为了保证效率，SmolVLM-2 通过图像平铺（image tiling）进行训练，这是一种流行的技术，除了全局图像外，还涉及处理同一图像的多个裁剪。然而为了获得更快的推理时间，我们不使用平铺。我们仅使用全局图像，除了像素混洗（ pixel shuffle）操作外，将每帧的视觉 token 限制为 64 个。

**通过层跳过实现更快的推理**：为了获得更快的推理时间，我们跳过 VLM 中的计算。先前的工作表明了在预训练模型中跳过层而不会显著降低性能。下游任务的最佳特征不一定来自 VLM 的最后一层。行动专家可以使用指定层的 $$N $$ 之前的所有特征，而不是最后一层的特征。在实践中，我们发现将 $$N$$设置为总层数的一半 $$N=L/2$$ 能最佳平衡速度和性能，有效地将 LLM 和动作专家的计算成本减半。

**流匹配动作专家**：动作专家 $$v_\theta$$被训练以从 VLM 特征中预测动作块 $$A_t = (a_t, \ldots, a_{t+n})$$ 。 实现 $$v_\theta$$依赖于transformer 架构。与之前的 VLA 架构不同，我们交错使用交叉注意力层和自注意力层，因此使用 conditional Flow Matching Transformer 作为 $$v_\theta$$ 。动作专家通过以下目标进行训练：

$$ \mathcal{L}^\tau(\theta) = \mathbb{E}_{p(A_t|\mathcal{o}_t), q(A_t^{\tau} | A_t)} \left[ \left\| v_\theta(A_t^{\tau}, \mathcal{o}_t) - u(A_t^{\tau} | A_t) \right\|^2 \right]$$

其中 $$\mathbf{o}_t$$ 表示从观察 $$o_t$$ 在第 $$N$$ 层 VLM 中提取的 VLM 特征，而 $$A_t^{\tau} = \tau A_t + (1-\tau) \epsilon$$ ， $$\epsilon \sim \mathcal{N}(0, \mathbf{I})$$ 。特别地， $$v_\theta$$ 被训练根据 VLM 特征和噪声动作 $$A_t^{\tau}$$ 输出向量场 $$u(A_t^{\tau} | A_t) = \epsilon - A_t$$ 。 我们从 $$Beta$$ 分布中采样 $$\tau$$ 以提高推理效率，我们为 $$v_\theta$$ 使用一个较少的隐藏层大小 $$0.75 \times d$$ ，其中 $$d$$ 是 VLM 的隐藏维度。

**交错的交叉和因果自注意力层**：动作专家 $$v_\theta$$ 根据 VLM 特征生成动作块， VLM 和动作专家之间的交互由注意力机制促进。与仅依赖自注意力（SA）或交叉注意力（CA） 的先前工作不同，我们采用交错的方法，其中每个 block 包含一个 CA 层或一个 SA 层 。这种设计选择也与标准的 VLM 架构不同，其中每个解码器 block 通常包括 SA 和 CA层 。在动作专家的前向传递中，动作和 VLM 特征之间的交互通过注意力进行，将 token 投影到 query, keys 和 values 。在我们的设置中，CA 层交叉关注 VLM 的 keys 和 values ，而 SA 层允许动作 token 相互关注。我们在 SA 层中使用因果注意力掩码，确保每个动作 token 只能注意 block 内的过去 token ，防止对未来动作依赖。 我们发现交错 CA 和 SA 层提供了更高的成功率和更快的推理时间。特别是通过 self-attention ，有助于形成更流畅的行动单元 $$A$$，这一点在针对实体机器人进行评估时尤为明显。

# **社区收集的预训练数据**

在机器人领域可用的数据量仍然比 CV 和 NLP 的数据量小几个数量级。机器人数据集的集成和扩展复杂，这是由于（i）数据集之间的差异 （ii）对人类专家进行数据收集的依赖。此外，机器人形态、传感器、执行模式、控制频率和数据格式的高度异质性导致了“数据孤岛” ，其集成分散的机器人数据集是具有挑战性的。

在这种情况下，低端机器人平台和标准化机器人库的出现直接缓解了这种数据异质性，为从业者提供了一个独特的机器人入口点。此外，由个人从业者收集的开源数据贡献使更大的机器人社区能够使用社区数据集，这些数据集是在多样化的真实世界环境中收集的——从学术实验室到家庭，利用开源技术扩展机器人学习。与遵循标准化协议的学术数据集不同，社区数据集自然跨越了不同的机器人形态、控制方案、摄像机视角和任务。此外，社区数据集通过嘈杂的演示、异构环境和多样化的对象交互反映了真实世界的复杂性，提供了有价值的预训练数据。在这项工作中，我们从 Hugging Face 中选择了 481 个社区数据集的一个子集，根据物理形态类型、情节数量、整体数据质量和帧覆盖率进行过滤。

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/135e612b431c411cb147f83989077eeb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv546L5aSn5L2g5piv6LCB:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTM2MjE3NDA1ODk1MTQ5In0%3D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1750240989&x-orig-sign=P4owXecPn3kFenWbrG%2BRyhyKtO0%3D)

**使用 VLM 进行任务注释。** 依赖于社区贡献的数据集需要标准化挑战。我们观察到任务注释中有大量的噪声，主要是给定数据集中的机器人预期行为的自然语言描述。关键的是，各种数据集包括模糊的占位符，如任务描述、过于模糊的命令，如“握住”或“向上”，或者完全缺乏指令。为了提高注释质量，我们使用现成的 VLM（Qwen2.5-VL-3B-Instruct）自动生成简洁的任务描述。对于每个数据集，我们采样代表性帧，并与原始指令一起提供。模型被提示生成一个简短的、动作导向的指令。

**摄像机视点标准化。** 使用社区数据集的另一个挑战在于使用的摄像机命名约定的高度可变性。例如，数据集可能根据特定情况将 images.laptop 指代为顶部、侧面或腕部安装的视图。我们发现这种不一致性在预训练期间是有害的，并且一致的摄像机排序对这种数据模式的训练是相当有益的。为了解决这个标准化挑战，我们手动将每个摄像机映射到标准化视图类型——优先考虑顶部、腕部和侧面视角——并分别将它们重命名为 OBS_IMAGE_1、OBS_IMAGE_2 和 OBS_IMAGE_3。对于具有额外视角的数据集，保留了顺序，但在训练期间丢弃了未使用的视角。

# **异步推理**

现代视觉运动策略输出 *action chunks* 序列 $$\pi(o_t) = A_t$$ 其中 $$A_t = (a_t, a_{t+1}, \ldots, a_{t+n})$$ 是一个长度为 $$n$$ （远大于1）排队在动作队列中的低级命令序列，起源于环境观察 $$o_t$$ 。通常机器人执行整个动作块 $$A_t$$ ，然后一个新的观察 $$o_{t+n}$$ 传递给策略 $$\pi$$ 以预测下一个块。这导致在每 $$n$$个时间步捕获的观察之间进行开环推理。机器人控制器交错动作块预测 $$A_t \leftarrow \pi(o_t)$$ 和块消耗 $$a_t \leftarrow \text{PopFront}(A_t)$$ ，在每个时间步 $$t $$ 计算新的动作块，并在重叠部分聚合预测的块。虽然自适应处理每个时间步 *t* 的每个观察 $$o_t$$ 的方法很有用，但这类方法依赖于持续不断地运行推理过程，在资源受限的场景下，如边缘部署，这可能是不可行的。

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/50912e0c2aca45449220a0709ef40625~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv546L5aSn5L2g5piv6LCB:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTM2MjE3NDA1ODk1MTQ5In0%3D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1750240989&x-orig-sign=nK9gISlppQBty7K9og2JnXMV1L8%3D)

一种资源消耗较少的方法是在预测新的动作块之前完全执行动作块 $$A$$ ，我们称之为同步（sync）推理。此外，同步推理有效地在每 $$n$$ 个时间步分配计算，从而在控制时减少了平均计算负担。相反，它固有地阻碍了机器人系统的响应能力，引入了由于机器人在计算 $$A$$时处于空闲状态而产生的盲延迟。

我们通过将动作块预测 $$A$$ 与动作执行 $$a_t \leftarrow \text{PopFront}(A_t)$$ 解耦，直接评估由于开环操作和运行时存在的延迟而导致的机器人系统适应性不足，开发了一个异步（async）推理栈，其中一个机器人客户端将观察 $$o_t$$ 发送到策略服务器，在推理完成后接收动作块 $$A_t$$ 。通过这种方式，我们避免了执行延迟，通过在控制循环仍在处理先前可用队列时触发动作块预测，将其与新入的队列聚合。反过来，异步推理通过增加观察被用于动作块预测的频率，收紧了动作预测和动作执行之间的循环。至关重要的是，将动作预测与动作执行解耦也直接允许在远程策略服务器上分配更多的计算资源，通过网络向机器人客户端发送动作，这在资源受限的场景中可能非常有效。

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/4a5e592d0f3743cba58907bacfd5826c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv546L5aSn5L2g5piv6LCB:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTM2MjE3NDA1ODk1MTQ5In0%3D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1750240989&x-orig-sign=qxT2dHpaHf8FR00talxgJ8skrMc%3D)

**实施细节** 。异步推理（i）通过更频繁地捕获观察来收紧控制循环，直接消除了运行时的空闲间隙，(ii)还直接允许在比通常搭载于自主机器人平台上的资源更强大的计算资源上运行推理。

在算法上，我们在机器人客户端通过从随时可用的队列中消耗动作来获得（i），直到满足队列中剩余动作数量的阈值条件 $$|\mathbf{A}_t|/n < g$$ 。当触发此条件时，将捕获的新环境观察发送到（可能远程的）策略服务器。为了避免在运行时观察到的冗余服务器调用和非理性行为，将联合空间中的近重复项进行比较，并丢弃近重复项。如果两个观察在联合空间中的距离小于预定阈值 $$\epsilon \in \mathbb{R}_+$$ ，则认为它们是近重复的。重要的是，当机器人客户端可用的队列变为空时，无论相似性如何，都会处理最近的观察。

有趣的是，可以分析异步推理的行为。首先，设 $$\ell$$ 为一个随机变量，模拟在发送观察 $$o$$ 后接收动作块 $$\mathbf{A}$$ 所需的时间，总共三部分之和，（i）发送观察 $$o$$ 在机器人客户端到策略服务器之间 $$t_C \rightarrow_S$$ 的时间，（ii）策略服务器上的推理延迟 $$\ell_s$$ 时间，（iii）发送 $$\mathbf{A}$$ 从机器人客户端到策略服务器 $$t_S \rightarrow _C$$ 的时间。假设独立性，$$\mathbb{E}[\ell] = \mathbb{E}[t_C \rightarrow_S] + \mathbb{E}[\ell_s] + \mathbb{E}[t_S \rightarrow _C]$$，这可以进一步简化为 $$\mathbb{E}[\ell] \approx \mathbb{E}[\ell_S]$$ ，假设通信时间在两个方向上相等且与推理延迟相比可忽略不计。

其次，设 $$\Delta t$$ 为环境的控制周期。实际的帧率是每秒 30 帧，$$\Delta t = 33\text{ms}$$。因此，运行时耗尽的队列（正在空闲等待新块）通过 $$g \geq \mathbb{E}[t_S]/\Delta t$$ 被避免了。队列阈值 g 对于 RobotClient 的操作可用性起着重要作用。

![](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/cca36109ec75470f9a4d543a072bd141~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oiR5piv546L5aSn5L2g5piv6LCB:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiNTM2MjE3NDA1ODk1MTQ5In0%3D&rk3s=e9ecf3d6&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1750240989&x-orig-sign=stcObXRwUqAMMHmQiClr4MHWmUs%3D)

图中（A）展示了动作块 $$|\mathbf{A}_t|$$ 的大小如何随时间演变，针对三个代表性的 $$g$$ 值，详细说明以下关键场景：

-   **序列限制（** $$g = 0$$ **）** ：客户端在将新观察发送到服务器之前耗尽整个块。在计算下一个块所需的往返延迟期间，队列为空，使机器人无法采取行动。这再现了完全顺序部署的行为，导致平均 $$\mathbb{E}[\ell_S]$$ 空闲秒数。
-   **异步推理（** $$g = 0.7$$ **）** ：允许客户端在触发新动作队列 $$\mathbf{A}_t$$ 的推理之前消耗大约 $$1 - g = 0.3$$ 的队列 $$\mathbf{A}_{t-1}$$ ，同时避免队列空。连续块之间的重叠提供了缓冲，以防止在没有 $$g = 1$$ 模式的全部代价的情况下对建模误差进行建模。通过聚合 $$\mathbf{A}_{t-1}$$ 和传入的 $$\hat{\mathbf{A}}_t$$ 之间的重叠时间步来获得更新后的队列 $$\mathbf{A}_t$$ 。
-   **计算密集型限制（** $$g = 1$$ **）** ：作为一个极端情况，每个时间步发送一个观察。因此，队列几乎总是满的，由于 $$\Delta t/\mathbb{E}[\ell_S] < 1$$ 只有轻微的锯齿。虽然最具有响应性，但这种设置每个控制周期一次前向传递，可能在有限硬件上非常昂贵。重要的是，由于客户端在服务器计算下一个块时消耗动作，可用队列永远不会再次填满。

图3（A）强调了由 $$g $$ 管理的权衡：小值导致空闲期，而 $$g \approx 1$$ 假设高度精确的模型并付出显著的计算代价。在实践中，选择 $$g \in (0, 1)$$ 可以在在反应性与资源预算之间取得平衡。

如果没有上述的相似性过滤器，机器人客户端将每 $$(1-g)n \cdot \Delta t$$ 秒发送观察进行处理，平均每 $$(1-g)n \cdot \Delta t + \mathbb{E}[\ell_S]$$ 秒接收一个新的动作块。观察相似性过滤器的存在会延长这一处理时间，并有助于避免因队列不断被传入的、几乎相同的动作块集成而导致机器人停滞。特别是，图（B）结果显示了一个队列，该队列充满了传入的动作，除非从处理管道中过滤出近重复观察。为了清晰起见，图（B）中的红色箭头突出显示了一个时间步，在该时间步中，观察相似性机制被绕过，迫使一个（几乎相同）的观察在队列为空时被处理。